# File: src/multi_agent_system/agents/audit_agent.py

import json
import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)

class AuditAgent:
    """
    The Audit Agent is responsible for reviewing the execution plan generated by the
    ContextResolutionAgent. Its primary tasks are:
    1. Enforce the "one sub-task per agent type" rule: Combine multiple sub-tasks
       routed to the same agent into a single, comprehensive clarified_command.
    2. Improve readability and clarity of the clarified_commands.
    """
    def __init__(self, ai_model=None):
        self.ai_model = ai_model
        if not self.ai_model:
            logger.warning("AuditAgent AI model is not initialized. Operating in Python-only mode for now.")

    def audit_plan(self, initial_plan: Dict[str, Any], conversation_history: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Takes an initial plan from ContextResolutionAgent and the full conversation history.
        Returns a refined plan with consolidated sub-tasks and improved clarity.
        """
        sub_tasks = initial_plan.get("sub_tasks", [])
        if not sub_tasks:
            return initial_plan # Nothing to audit

        # First, check if auditing is strictly necessary (i.e., if duplicates exist)
        agent_routes = [task.get("route_to") for task in sub_tasks if task.get("route_to")]
        if len(agent_routes) == len(set(agent_routes)):
            # No duplicate agent routes, proceed with a light touch or skip AI call
            logger.info("AuditAgent: No duplicate agent routes found. Applying minor readability improvements.")
            return self._apply_readability_to_plan(initial_plan)

        logger.info("AuditAgent: Duplicate agent routes found. Consolidating sub-tasks with AI assistance.")
        
        # Build context for the Audit Agent's prompt
        context_for_prompt = self._build_context_string_from_structured(conversation_history)
        prompt = self._build_audit_prompt(initial_plan, context_for_prompt)

        try:
            if not self.ai_model:
                 logger.warning("AuditAgent AI model not available for full consolidation. Falling back to Python-only consolidation.")
                 return self._python_consolidate_plan(initial_plan)

            response = self.ai_model.generate_content(prompt)
            cleaned_response = response.text.strip().replace('```json', '').replace('```', '')
            parsed_json = json.loads(cleaned_response)
            
            if "sub_tasks" not in parsed_json or not isinstance(parsed_json.get("sub_tasks"), list):
                logger.warning(f"AuditAgent returned malformed JSON. Falling back to Python-only consolidation. Response: {cleaned_response}")
                return self._python_consolidate_plan(initial_plan)
            
            # Additional check to ensure AI didn't invent new agents or malform
            for task in parsed_json["sub_tasks"]:
                if "route_to" not in task or "clarified_command" not in task:
                    logger.warning(f"AuditAgent's JSON output missing required fields. Falling back to Python-only consolidation. Task: {task}")
                    return self._python_consolidate_plan(initial_plan)

            # Ensure the "at most one sub-task per agent type" is enforced by the AI
            final_agent_routes = [task.get("route_to") for task in parsed_json["sub_tasks"]]
            if len(final_agent_routes) != len(set(final_agent_routes)):
                logger.warning(f"AuditAgent's AI output still contains duplicate agent routes. Falling back to Python-only consolidation. AI output: {parsed_json}")
                return self._python_consolidate_plan(initial_plan)

            return parsed_json

        except (json.JSONDecodeError, TypeError, Exception) as e:
            logger.error(f"AuditAgent: Failed to parse AI response or an error occurred: {e}\nResponse was: {getattr(response, 'text', 'N/A')}")
            return self._python_consolidate_plan(initial_plan) # Fallback to Python if AI fails

    def _python_consolidate_plan(self, initial_plan: Dict[str, Any]) -> Dict[str, Any]:
        """
        A deterministic Python-based consolidation fallback for the audit agent.
        Combines tasks for the same agent into a single clarified_command.
        """
        sub_tasks = initial_plan.get("sub_tasks", [])
        combined_tasks: Dict[str, Dict[str, Any]] = {}

        for task in sub_tasks:
            route_to = task.get("route_to")
            clarified_command = task.get("clarified_command", "").strip()

            if not route_to or not clarified_command:
                continue

            if route_to not in combined_tasks:
                combined_tasks[route_to] = {
                    "route_to": route_to,
                    "clarified_command_parts": [clarified_command]
                }
            else:
                combined_tasks[route_to]["clarified_command_parts"].append(clarified_command)

        final_sub_tasks = []
        for agent_name, combined_data in combined_tasks.items():
            parts = combined_data["clarified_command_parts"]
            
            # Simple joining strategy for Python fallback
            combined_command = " AND ".join(parts) if len(parts) > 1 else parts[0]
            
            final_sub_tasks.append({
                "route_to": agent_name,
                "clarified_command": combined_command
            })
        return {"sub_tasks": final_sub_tasks}

    def _apply_readability_to_plan(self, initial_plan: Dict[str, Any]) -> Dict[str, Any]:
        """
        Applies minor readability improvements to clarified_commands without consolidation.
        This is for when no duplicate agents are found.
        """
        for task in initial_plan.get("sub_tasks", []):
            if "clarified_command" in task:
                task["clarified_command"] = task["clarified_command"].strip() # Basic cleanup
        return initial_plan


    def _build_context_string_from_structured(self, history: List[Dict[str, Any]]) -> str:
        """
        Formats the structured conversation history into a simple string for the AI prompt.
        """
        if not history:
            return "No conversation history available."
        
        # We use the last 2 turns (4 entries max) to keep the prompt focused
        recent_turns = history[-2:]
        
        formatted_history = []
        for turn in recent_turns:
            formatted_history.append(f"USER: {turn.get('user_input', '')}")
            # Use 'response' or 'clarified_input' if 'response' is too verbose
            formatted_history.append(f"ASSISTANT (Clarified): {turn.get('clarified_input', '')}")
        
        return "\n".join(formatted_history)


    def _build_audit_prompt(self, initial_plan: Dict[str, Any], conversation_history: str) -> str:
        """
        Builds the prompt for the Audit Agent, with enhanced intelligence for grouping.
        """
        initial_plan_json = json.dumps(initial_plan, indent=2)

        return f"""
        You are an AI Audit Agent. Your role is to take an initial execution plan and refine it.
        Your MOST CRITICAL instruction is to ensure that the final plan contains **AT MOST ONE SUB-TASK ENTRY FOR EACH UNIQUE AGENT TYPE**.

        If the initial plan contains multiple sub-tasks that route to the *same* agent (e.g., multiple 'JournalAgent' entries),
        you MUST combine their `clarified_command`s into a **single, comprehensive `clarified_command`** for that agent's ONE entry.

        For `JournalAgent` in particular:
        *   **Identify Overarching Topics:** Look for common themes or a single conceptual "document" that multiple journal-related commands contribute to.
        *   **Summarize Thematically:** Consolidate all related information under one logical heading or purpose within the `clarified_command`.
        *   **DO NOT prefix with "add to journal"**: The `route_to` already indicates it's a journal action. The `clarified_command` should be the *content* or *request for content* itself.

        Make the combined `clarified_command` as clear, concise, and easy-to-read as possible, without losing any original intent. Use structured formats (like bullet points or distinct sections) within the `clarified_command` if combining multiple distinct items for readability.

        You are aware of the following recent conversation history to help you in consolidation:
        ---
        ### **RECENT CONVERSATION HISTORY**
        {conversation_history}
        ---

        ---
        ### **INITIAL EXECUTION PLAN TO AUDIT**
        {initial_plan_json}
        ---

        ---
        ### **CORE PRINCIPLES (MANDATORY)**
        1.  **Single Entry Per Agent Type:** Each `route_to` value (e.g., "TaskAgent", "JournalAgent") can appear **only once** in the final `sub_tasks` list.
        2.  **Combine & Clarify Thematically:** Merge all related `clarified_command`s for a single agent into one consolidated, *thematically coherent* command.
        3.  **Preserve Original Intent:** Do not lose any details or actions from the original `clarified_command`s.
        4.  **Improve Readability:** Structure the combined `clarified_command` for easy understanding by a human or downstream agent.
        5.  **Output ONLY JSON:** Your response must be a JSON object matching the structure of the `initial_plan`.

        ---
        ### **RESPONSE FORMAT (JSON ONLY)**
        ```json
        {{
        "sub_tasks": [
            {{
            "route_to": "SelectedAgentName",
            "clarified_command": "The fully consolidated and self-contained command for this specific step,
                                  combining all original intentions for this agent into one clear instruction."
            }}
            // ... only one entry per agent type
        ]
        }}
        ```

        ---
        ### **EXPERT EXAMPLE (Study this carefully)**

        **Initial Plan (Example of what you might receive - based on your latest complex input):**
        ```json
        {{
            "sub_tasks": [
                {{"route_to": "JournalAgent", "clarified_command": "Description: Explanation of pros and cons"}},
                {{"route_to": "TaskAgent", "clarified_command": "add task to call John"}},
                {{"route_to": "JournalAgent", "clarified_command": "Katalog: Diisi BMC dan deskripsi produk"}},
                {{"route_to": "JournalAgent", "clarified_command": "Etalase: Diisi BMC dan deskripsi produk"}},
                {{"route_to": "JournalAgent", "clarified_command": "Target (sesuai dengan target kelompok)"}},
                {{"route_to": "JournalAgent", "clarified_command": "Rencana usaha: BMC Untuk permodalan (pinjaman usaha ke BMS)"}},
                {{"route_to": "JournalAgent", "clarified_command": "Persyaratan peminjaman: Akad/surat kontrak BMS, Kartu pelajar dan materei"}},
                {{"route_to": "TaskAgent", "clarified_command": "complete task 'send email'"}}
            ]
        }}
        ```

        **Audited Plan (Example of what you MUST produce - intelligent thematic grouping):**
        ```json
        {{
            "sub_tasks": [
                {{
                    "route_to": "JournalAgent",
                    "clarified_command": "Store comprehensive business plan details:
                    - **Overview:** Explanation of pros and cons.
                    - **Catalog Details:** Includes BMC and product description.
                    - **Showcase/Etalase:** Contains BMC and product description.
                    - **Target Audience:** Aligned with the specific target group.
                    - **Business Plan Funding:** BMC for business capital (loan to BMS).
                    - **Loan Requirements:** Akad/contract with BMS, student card, and stamp duty."
                }},
                {{
                    "route_to": "TaskAgent",
                    "clarified_command": "Perform multiple task actions: Add task to call John and complete task 'send email'."
                }}
            ]
        }}
        ```
        ---
        Now, audit the provided initial plan and produce the refined execution plan. Respond with ONLY the valid JSON object.
        """